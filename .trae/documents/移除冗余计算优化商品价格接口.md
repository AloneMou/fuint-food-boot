# 商品列表页价格计算优化方案（去除冗余计算）

经过详细的代码分析，发现原有的 `calculateCartGoods` 方法在商品列表页场景下存在严重的性能浪费。

## 1. 问题根源

在 `OpenGoodsServiceImpl` 调用 `calculateCartGoods` 时：
*   传入 `couponId = null`：**不计算优惠券抵扣**。
*   传入 `isUsePoint = false`：**不计算积分抵扣**。
*   传入 `orderMode = ONESELF`：**不计算运费**。

然而，`calculateCartGoods` 内部依然执行了以下高耗时操作（陪跑）：
1.  **加载用户所有优惠券** (`getAvailableCoupons`)：查询数据库并遍历匹配商品。
2.  **加载商品详情** (`processCartItems`)：再次查询商品和 SKU 信息（尽管外部已经有了）。
3.  **加载系统配置**：多次查询积分、运费设置。

实际上，该场景下唯一生效的计算逻辑仅为 **会员等级折扣**。

## 2. 优化方案

完全移除对 `calculateCartGoods` 的调用，改为在 `OpenGoodsServiceImpl` 中直接计算会员折扣价格。

### 具体步骤

1.  **预加载会员折扣率**：
    *   在 `getGoodsList` 方法入口处，调用 `MemberService` 和 `UserGradeService` 获取当前用户的会员折扣率。
    *   仅需查询 1 次数据库，替代之前的 N 次（N=SKU总数）。

2.  **内存计算价格**：
    *   在遍历 SKU 时，直接使用公式计算：
        `DynamicPrice = SKU原价 * 会员折扣率`
    *   若商品不支持会员折扣（`isMemberDiscount == "N"`），则 `DynamicPrice = SKU原价`。

3.  **保留多线程**：
    *   保留之前引入的 `goodsPriceExecutor`，用于并行处理 DTO 转换和规格组装，进一步缩短响应时间。

## 3. 预期效果

*   **数据库查询骤减**：从 `N * (商品查+券查+配置查)` 降为 `1次会员查`。
*   **响应时间质变**：预计从 14秒 降低到 毫秒级（主要取决于数据库查询商品列表的速度）。

## 4. 代码变更

**OpenGoodsServiceImpl.java**

*   注入 `MemberService`, `UserGradeService`。
*   新增 `getMemberDiscount` 私有方法。
*   替换 `buildGoodsVO` 中的 `openApiOrderService.calculateCartGoods` 调用。

