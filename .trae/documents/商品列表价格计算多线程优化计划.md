# 多线程优化商品价格计算方案

为了解决商品数量较多时动态价格计算慢的问题，我计划通过引入**多线程并行处理**来优化 `OpenGoodsServiceImpl` 的 `getGoodsList` 方法。

## 1. 核心思路

当前的实现是**串行**遍历所有商品，并对每个商品依次计算 SKU 价格和规格。当商品数量较多时，累积的 I/O（数据库查询、价格计算逻辑）会导致响应时间线性增长。
优化方案是将每个商品的计算任务提交到**线程池**中并行执行，最后聚合结果。

## 2. 具体实施步骤

### 2.1 新增专用线程池配置

在 `ThreadPoolConfig.java` 中新增一个名为 `goodsPriceExecutor` 的线程池，专门用于商品价格计算，避免与现有的 `userSyncExecutor` 争抢资源。

* **配置参数**：

  * 核心线程数：10 (根据业务并发度调整)

  * 最大线程数：20

  * 队列容量：500

  * 线程名称前缀：`goods-price-thread-`

  * 拒绝策略：`CallerRunsPolicy` (队列满时由主线程执行，防止丢数据)

### 2.2 重构 `OpenGoodsServiceImpl`

1. **注入线程池**：注入新定义的 `goodsPriceExecutor`。
2. **抽取处理逻辑**：将原 `for` 循环内部针对单个 `MtGoods` 的处理逻辑（DTO转换、SKU价格计算、规格处理）抽取为一个独立的私有方法 `buildGoodsVO(MtGoods goods, ...)`，确保局部变量的线程安全。
3. **并行执行**：

   * 使用 `CompletableFuture.supplyAsync` 提交每个商品的计算任务。

   * 使用 `CompletableFuture.join` 等待所有任务完成。

   * 收集结果并保持原有的商品顺序。

### 2.3 预期代码变更

**ThreadPoolConfig.java**

```java
@Bean(name = "goodsPriceExecutor")
public ThreadPoolExecutor goodsPriceExecutor() {
    // ... 配置新线程池 ...
}
```

**OpenGoodsServiceImpl.java**

```java
@Resource(name = "goodsPriceExecutor")
private ThreadPoolExecutor goodsPriceExecutor;

@Override
public List<CGoodsListRespVO> getGoodsList(List<MtGoods> goodsLs, Integer userId) {
    // ... 前置查询逻辑不变 ...

    // 并行处理
    List<CompletableFuture<CGoodsListRespVO>> futures = goodsLs.stream()
        .map(goods -> CompletableFuture.supplyAsync(
            () -> buildGoodsVO(goods, userId, skuMap, specMap), 
            goodsPriceExecutor
        ))
        .collect(Collectors.toList());

    // 等待所有完成并收集结果
    return futures.stream()
        .map(CompletableFuture::join)
        .collect(Collectors.toList());
}

// 抽取的单商品处理方法
private CGoodsListRespVO buildGoodsVO(MtGoods goods, Integer userId, Map<Integer, List<MtGoodsSku>> skuMap, Map<Integer, List<MtGoodsSpec>> specMap) {
    // ... 原循环体内的逻辑 ...
}
```

## 3. 风险与验证

* **线程安全**：已分析 `OpenApiOrderService.calculateCartGoods`，虽然存在潜在风险，但在本场景下（不同商品独立计算）是相对安全的。通过抽取方法确保变量局部化进一步降低风险。

* **事务问题**：该查询操作为只读，不涉及事务回滚问题。

* **顺序保证**：使用 Stream API 的收集方式可以天然保证结果列表的顺序与入参 `goodsLs` 一致。

